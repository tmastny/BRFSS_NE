---
title: "MRP Primer"
author: "Tim"
date: "11/9/2017"
output: 
  html_document:
    keep_md: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, 
                      results='show', cache=TRUE, autodep=TRUE)
```
## Data and references

I'll be working through Kastellec et al's MRP primer. The paper and datasets are hosted [at his website](http://www.princeton.edu/~jkastell/mrp_primer.html). 

I have a few goals in this exercise:

1. Verify Kastellec's findings.

2. Attempt a full Bayesian modeling uses `Stan` and `brms`. 

3. Compare

    a. multilevel vs. fixed effects models

    b. results before and after poststratification
  

## Reproduce and Verify

Our goal is to estimate public opinion on gay marriage using this poll:

```{r}
library(tidyverse)
library(arm)
marriage.data <- foreign::read.dta('gay_marriage_megapoll.dta', convert.underscore=TRUE)
marriage.data %>% as.tibble()
```

## Disaggregration 

The simplest way to gauge politic opinion is to disaggregrate the data. Break down the national survey into states and calculate the percentage saying `yes.of.all`. That calculation is very simple with `dplyr`:

```{r}
marriage.opinion <- marriage.data %>%
  group_by(statename) %>%
  summarise(support = mean(yes.of.all))
marriage.opinion
```

Let's map it. First we setup our mapping tools.

```{r}
library(maps)
library(mapdata)
library(ggmap)
states <- map_data("state")

ditch_the_axes <- theme(
  axis.text = element_blank(),
  axis.line = element_blank(),
  axis.ticks = element_blank(),
  panel.border = element_blank(),
  panel.grid = element_blank(),
  axis.title = element_blank()
  )
```

Next, we need to combine our state level data with the national map `states`.

```{r}
state_opinion <- states %>%
  inner_join(marriage.opinion, by=c('region' = 'statename')) %>% 
  as.tibble()

ggplot(data=state_opinion, aes(x = long, y = lat, group = group)) +
  geom_polygon(aes(fill = support), color = "black") +
  coord_fixed(1.3) + 
  theme_bw() +
  ditch_the_axes + 
  scale_fill_gradient2(low = 'red', mid = 'white', high = 'blue',
                       midpoint = 0.5)
```

White indicates majority support, with colors trending towards blue indicate increased support. Red colors are states below majority support. Another useful way to look at the map is to the set the color midpoint at the mean `r mean(state_opinion$support)`.

Alternatively, we can look at an graph sorted by the level of support. Providing an alternative to maps is recommended by Gelman. 

```{r}
marriage.opinion %>% na.omit() %>%
  ggplot(aes(x=support, y=reorder(statename, support))) +
  geom_point() + 
  geom_vline(xintercept = mean(marriage.opinion$support), linetype=2)
```



## Combining Data

Likewise, we may want to use other state level predictors from other sources:

```{r}
Statelevel <- foreign::read.dta("state_level_update.dta",convert.underscore = TRUE)
Statelevel <- Statelevel[order(Statelevel$sstate.initnum),]
Statelevel %>% as.tibble()
```

Finally, we need to load in the US census for poststratification:

```{r}
Census <- foreign::read.dta("poststratification 2000.dta",convert.underscore = TRUE)
Census <- Census[order(Census$cstate),]
Census$cstate.initnum <-  match(Census$cstate, Statelevel$sstate)
Census %>% as.tibble()
```

An important warning with poststratification techniques is that you need demographic information for every intersection of your model predictors. For example, if your model predicts opinion based on gender, race, age, and education you will need to know the number of African American females aged 18 to 29 years old who are college graduates. Do we have that information?

```{r}
Census %>%
  group_by(crace.WBH, cage.cat, cedu.cat, cfemale) %>%
  summarise(count = sum(.freq)) %>%
  filter(crace.WBH==2, cfemale==1, cage.cat==1)
```

Next, we need to create a list of indicator variables to poststratify the survey. First, on the mega-poll level, we recode some of the indicator variables and bring some data in from the State level statistics.

```{r}
# from 1 for white males to 6 for hispanic females
marriage.data$race.female <- (marriage.data$female *3) + marriage.data$race.wbh

# from 1 for 18-29 with low edu to 16 for 65+ with high edu
marriage.data$age.edu.cat <- 4 * (marriage.data$age.cat -1) + marriage.data$edu.cat

# proportion of evangelicals in respondent's state
marriage.data$p.evang.full <- Statelevel$p.evang[marriage.data$state.initnum]

# proportion of mormon's in respondent's state
marriage.data$p.mormon.full <-Statelevel$p.mormon[marriage.data$state.initnum]

# combined evangelical + mormom proportions
marriage.data$p.relig.full <- marriage.data$p.evang.full + marriage.data$p.mormon.full

# kerry's % of 2-party vote in respondent's state in 2004
marriage.data$p.kerry.full <- Statelevel$kerry.04[marriage.data$state.initnum]
```

As an aside, I really dislike this coding scheme as it seems to make the interpretation of the categorical quantities very difficult to understand. I'd like to try an alterative reformulation of the indicators later, or have a function to convert them a la `tidybayes` to easily understand. 

Next, we code the system census in the same way.

```{r}
Census$crace.female <- (Census$cfemale *3) + Census$crace.WBH 
Census$cage.edu.cat <- 4 * (Census$cage.cat -1) + Census$cedu.cat 
Census$cp.evang.full<-  Statelevel$p.evang[Census$cstate.initnum]
Census$cp.mormon.full <- Statelevel$p.mormon[Census$cstate.initnum]
Census$cp.relig.full <- Census$cp.evang.full + Census$cp.mormon.full
Census$cp.kerry.full <-  Statelevel$kerry.04[Census$cstate.initnum]
```

## Fitting a regression

We'll start with fitting the multilevel model specified in the paper. 

```{r}
individual.model <- glmer(formula = yes.of.all ~ 
                            (1|race.female) + (1|age.cat) +
                            (1|edu.cat) + (1|age.edu.cat) + 
                            (1|state) + (1|region) + (1|poll) +
                            p.relig.full + p.kerry.full, 
                          data=marriage.data, family=binomial(link="logit"))
```
```{r}
display(individual.model)
```

This model estimates the mean (via offsets using group-level intercepts) for each cross-classification of demographics and states; the exact poststratification we are interested in.  

Analyzing the coefficients, we first see that an individual's religion indicates they would be less inclined to support gay marriage with a certainty. This result is expeted. However, voting for Kerry in the previous elect has an estimated positive effect, although the confidence interval includes zero. This is suprisingly since republicans tend to not support gay marriage and tend to be more religious.

Let's take a look at the actual group-level intercepts.

```{r}
tibble(Intercept = ranef(individual.model)$race.female$`(Intercept)`,
       se = se.ranef(individual.model)$race.female[,1]) %>%
  mutate(race = c('White male', 'White female', 'Black male', 'Black female',
                  'Hispanic male', 'Hispanic female'))
```

The standard error on the estimates is fairly large. However, some estimates have a confidence interval just above (or below) zero. Looking at the statistics, men support gay marriage less on average than women in each strata. Moreover, whites seem to support gay marriage less than any other race, with the notable except of Hispanic men. 





## Poststratifying




Note to self: I want to create a scatterplot with state abbreviations using `geom_text` comparing disaggregrate to multilevel. In fact, I want to compare them against both MRP and MR.

```{r}
unique(Census$cstate)
```


## Comparing model to full Bayesian


We'll fit the model to flat priors without better information and to match the MLE estimate.

Based on an initial attempted fit, I think I'll need to provide some priors to get quick convergence. 

```{r, results='hide'}
# library(brms)
# individual.model <- brm(yes.of.all ~ 
#                             (1|race.female) + (1|age.cat) +
#                             (1|edu.cat) + (1|age.edu.cat) + 
#                             (1|state) + (1|region) + (1|poll) +
#                             p.relig.full + p.kerry.full, 
#                           data=marriage.data, family=binomial(link="logit"))
```
```{r}
# display(individual.model)
# summary(individual.model)
```






